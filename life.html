<!DOCTYPE html>

<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<style type="text/css">
  ::selection { background: transparent;  }
</style>
<script>

var stg = {
     minx : 30,      // left x-margin
     miny : 30,      // top y-margin
     width : 600,    // total width
     height : 600,   // total height
     hspacing : 30,  // initial grid spacing (left to right)
     vspacing : 30,  // initial grid spacing (top to bottom)
     data : null,    // typedarray of cell values 1=alive, 0=dead
     steps : 2000,   // # of steps to simulate
     active : 0,     // active vs idle
     init_with_gliders : 1  
};

function zoom() {
    redraw(1);
}
function clear_grid() {
   stg.init_with_gliders = 0;
   redraw(1);
}
function get_gliders() {
    stg.init_with_gliders = 1;
    redraw(1);
}

function set_pos(i,j) {
   if (i < stg.mx && j < stg.my) {
      stg.data[i * stg.my + j] = 1;
      draw_cell(i,j,1);
   }
}

var left_down = 0;
var right_down = 1;
var left_up = 2;
var right_up = 3;

function init_glider(x,y,orientation) {
    var flip = (orientation & 2);
    set_pos(x+1,y+flip);
    if ((orientation & 1) === 1)  // right
       set_pos(x+2,y+1);
    else 
       set_pos(x,y+1);
    set_pos(x+2,y+2-flip);
    set_pos(x+1,y+2-flip);
    set_pos(x+0,y+2-flip);
}


function label() {
    // label the axes
    var c=document.getElementById("myCanvas");
    var ctx=c.getContext("2d");
    ctx.font="12px Arial";
    ctx.fillStyle="#000000";
    
    var labels = Math.floor((stg.width - stg.minx) / stg.hspacing);
    var i=0;
    for(i=0;i<labels;i++) {
	x = stg.minx + i * stg.hspacing + (stg.hspacing *.25);
	y = 10;
	ctx.fillText(i,x,y);	
    }
    labels = Math.floor((stg.height - stg.miny) / stg.vspacing);
    for(i=0;i<labels;i++) {
	x = 0
	y = stg.miny + i * stg.vspacing + (stg.vspacing *0.75);
	ctx.fillText(i,x,y);	
    }


}
function canvclick(ev) {
    // paint a cell that someone clicks on                          
    var canvas = document.getElementById("myCanvas");
    var crect = canvas.getBoundingClientRect();
    var x = ev.x - crect.left;
    var y = ev.y - crect.top; 

    if (x <= stg.minx ||  y < stg.miny)  { 
       return;
    }
    var px = Math.floor((x-stg.minx) / stg.hspacing);
    var py = Math.floor((y-stg.miny) / stg.vspacing);

    var p = stg.my * px + py;
    if (p < stg.elements) {
        var nv = 1-stg.data[p]; //toggle
        draw_cell(px,py,nv);
	stg.data[p] = nv;
    }
    else {
	alert("Error");
    }

}

function startup() {
    // listen for mouse down events on the canvas
    var c=document.getElementById("myCanvas");
    c.addEventListener("mousedown", canvclick, false);
}

function evaluate_cell(i,j) {
    // see if (i,j) is in range and alive

    // toroidal mesh
    if (i < 0) 
       i = i + stg.mx;
    if (j < 0) 
       j = j + stg.my;
    if (i >= stg.mx) 
       i = i - stg.mx;
    if (j >= stg.my)
       j = j - stg.my;

    if (i>=0 && i<stg.mx) { 
       if (j>=0 && j < stg.my) { 
            var p = stg.my * i + j;
            if (stg.data[p]) {
                return 1;
            }
       }
    }
    return 0;
}
function evaluate(i,j,v) {
    // look at 8 neighbors and see how many are alive
    var c  = 0;
    var ipr  = i-1;
    var inx  = i+1;
    var jpr  = j-1;
    var jnx  = j+1;

    c = c + evaluate_cell(ipr,jpr);
    c = c + evaluate_cell(i,jpr);
    c = c + evaluate_cell(inx,jpr);

    c = c + evaluate_cell(ipr,j);
    c = c + evaluate_cell(inx,j);

    c = c + evaluate_cell(ipr,jnx);
    c = c + evaluate_cell(i,jnx);
    c = c + evaluate_cell(inx,jnx);


    if (c === 3) {  
        // 3 neighbors -> birth
        return 1;
    }
    else if (c === 2) {   
        // 2 neighbors -> no change
        return v;
    }
    // over-population  or under-population -> death
    return 0;
}

function draw_cell(i,j,z) {
    // paint one cell (i,j) red if z=1 and white otherwise
    // convert to canvas coordinates
    var x = stg.minx + i * stg.hspacing;
    var y = stg.miny + j * stg.vspacing;

    var c=document.getElementById("myCanvas");
    var ctx=c.getContext("2d");
    if (z === 1) {
	ctx.fillStyle="#FF0000"; // red
    }	
    else {
	ctx.fillStyle="#FFFFFF"; // white
    }
    // the +/-1 one stuff is to avoid over-drawing the grid
    ctx.fillRect(x+1,y+1,stg.hspacing-1,stg.vspacing-1);
}

function stop() {
   // turn off the periodic redrawing
   clearInterval( stg.interval );    
   stg.active = 0;                  
   var y = document.getElementById("status");
   y.innerHTML = "idle";
}

function simulate_pre() {
   if (stg.active === 1) { 
      return;
   }
   // set up a timer to call simulate periodically
   stg.i = 0;                      
   var y = document.getElementById("status");
   y.innerHTML = "running";

   var slider = document.getElementById("speed");
   stg.active = 1;
   stg.interval = setInterval(function(){simulate()},(10-slider.value)*20);
}

function change_steps() {
   // handle the text field with the # of steps to simulate
   var y = document.getElementById("steps");
   stg.steps = Math.floor(y.value);
   if (stg.steps < 0) {   
       stg.steps = 0;
   }
}

function simulate() {
    // simulate a certain # of steps and then stop
    stg.i = stg.i + 1;
    if ( stg.active === 0 || stg.i  >=  stg.steps) {
       stop();
    }
    simulate_one(); 
}

function simulate_one() {
    // evaluate one grid and make a new one. drawing as we go.
    var data2 = new Int8Array(stg.elements);
    var i=0;
    var j=0;
    for(i=0;i<stg.mx;i++) {
        for(j=0;j<stg.my;j++) {
	    var p = stg.my * i + j;
	    var v = stg.data[p];
	    var z = evaluate(i,j,v);
	    data2[p] = z;
            if (z !== v)                   
                draw_cell(i,j,z);
        }
    }
    delete stg.data;
    stg.data = data2;
}

function redraw(clear) {
    // draw the grid and zero out the array
    var c=document.getElementById("myCanvas");
    var ctx=c.getContext("2d");

    var slider = document.getElementById("points");

    stg.hspacing = 3*slider.value;
    stg.vspacing = 3*slider.value;

    if (clear)  {
	ctx.clearRect(0,0,stg.width,stg.height);
    }
    label();
    var i=0;
    var j=0;
                              

    // vertical lines
    for (i=0;i<stg.width;i+=stg.hspacing) {
	ctx.beginPath();
	ctx.moveTo(stg.minx + i, stg.miny);
	ctx.lineTo(stg.minx + i, stg.miny+stg.height);
	ctx.stroke();
    }
    
    // horizontal lines
    for (j=0;j<stg.height;j+=stg.vspacing) { 
	ctx.beginPath();
	ctx.moveTo(stg.minx,           stg.miny+j);
	ctx.lineTo(stg.minx+stg.width, stg.miny+j);
	ctx.stroke();
    }

    stg.mx = Math.floor((stg.width-stg.minx) / stg.hspacing);
    stg.my = Math.floor((stg.height-stg.miny) / stg.vspacing);

    stg.elements = stg.mx * stg.my;
    if (stg.data) { 
       delete stg.data;
       stg.data = null;
    }                                  
    stg.data = new Int8Array(stg.elements);

    for(i=0;i<stg.elements;i++) { 
       stg.data[i] = 0;
    }

    if (stg.init_with_gliders) {
        var i; // orientation
        var j; 
        for (i=0;i<2;i++) 
           for (j=0;j<4;j++)  
               init_glider(j*10,i*10,i);
    }
}

</script>
</head>
<body>

<p>Cells are born if they have 3 neighbors. They live if they have 2
or 3 neighbors and die otherwise. When the status is idle, click to
add live cells. Click on live cells to remove them.  

<p>You can also add/remove cells while the simulation is running.
Any added cells need to be near 2 other cells when placed otherwise
they will immediately die according to the rules of the game.

<br> <br> <br> 


<canvas id="myCanvas" width="600" height="600" 
     style="border:1px solid #000000;"> 
Your browser does not support the HTML5 canvas tag.
</canvas> <br>

<button type="button"   
        onclick="simulate_pre()">Start</button>
&nbsp;
&nbsp;
&nbsp;
<button type="button"   
        onclick="stop()">Stop</button>


&nbsp;
&nbsp;
&nbsp;
<button type="button"   
        onclick="clear_grid()">Clear</button>
&nbsp;
&nbsp;
&nbsp;
<button type="button"   
        onclick="get_gliders()">Give me gliders!</button>

<br>

Grid spacing: <input type="range" id="points" 
       min="1" max="20" value="10"
       onchange="zoom()">
<br>
Speed: <input type="range" id="speed" 
       min="1" max="10" value="5">
<br>
Steps: <input type="text" id="steps" value="2000"
       onchange="change_steps()">

<br>
Status: <a id="status">idle</a>

<script>
redraw(1)
startup()
</script>

</body>
</html>

